h2. Table of Contents

# "What is Robotlegs":#whatIsRobotlegs
## "Dependency Injection":#dependencyInjection
## "The Context":#theContext
## "MVC+S":#mvcs 
## "Context":#context
## "Model & Models":#modelAndModels
## "View & Mediators":#viewAndMediators
## "Controller & Commands":#controllersAndCommands
## "Service & Services":#serviceAndServices
## "Framework Events":#frameworkEvents
# "Commands":#commands
## "Command Responsibilities":#commandResponsibilities
## "Triggering Commands ":#triggeringCommands 
## "Chaining Commands":#chainingCommands
## "Decoupling Application Tiers":#decouplingTiers
# "Mediators":#mediators
## "Mediator Responsibilities":#mediatorResponsibilities
## "Mapping a Mediator":#mappingAMediator
## "Automatic Mediation of View Components":#automaticMediation
## "Manually Mediation of View Components":#manualMediation
## "Mapping the Main Application (_contextView_) Mediator":#mappingTheContextView
## "Accessing a Mediator's View Component":#accessingMediatorViewComponent 
## "Adding Event Listeners to a Mediator":#addingEventListenersToMediators 
## "Listening for Framework Events":#mediatorsListeningFroFrameworkEvents 
## "Dispatching Framework Events":#MediatorsDispatchingFrameworkEvents 
## "Listening for View Component Events":#mediatorsListeningForComponentEvents 
## "Accessing Models and Services via a Mediator":#accessingModelsAndServicesFromMediators 
## "Accessing Other Mediators":#accessingOtherMediatorsFromAMediator 
# "Models":#models 
## "Model Responsibilities":#modelResponsibilities 
## "Mapping a Model":#mappingAModel 
## "Dispatching Events from a Model":#dispatchingEventsFromModel 
## "Listening for Framework Events in a Model":#listeningForEventsInModel 
# "Services":#services 
## "Responsibilities of Services":#serviceResponsibilities 
## "Mapping a Service":#mappingService 
## "Listening for Framework Events in a Service":#serviceListeningForFrameworkEvents 
## "Dispatching Framework Events":#serviceDispatchingFrameworkEvents 
# "Unit Testing":#unitTesting 

h2(#whatIsRobotlegs). What is Robotlegs

Robotlegs is a pure AS3 micro-architecture (framework) for developing Flash, Flex, and AIR applications. Robotlegs is narrowly focused on wiring application tiers together and providing a mechanism by which they communicate. Robotlegs seeks to speed up development while providing a time tested architectural solution to common development problems. The framework supplies a default implementation based on the Model-View-Controller meta-design pattern. Robotlegs is not interested in locking you into the framework, your classes are just that, your classes, and should be easily transferable to other frameworks should the need or desire to do so arise in the future.

h2(#dependencyInjection). Dependency Injection

Robotlegs revolves around the "Dependency Injection":http://www.insideria.com/2009/09/as3-dependency-injection-demys.html design pattern.

bq. At the simplest, Dependency Injection is that act of supplying or objects with their instance variables or properties. When you pass a variable to the constructor of a class, you are using Dependency Injection. When you set a property on a class, you are using Dependency Injection. If you aren't coding your AS3 in a strictly procedural or linear fashion, the odds are that you are making use of Dependency Injection right now.

Robotlegs uses automated, metadata based Dependency Injection. This is provided as a convenience for the developer and has the advantage of greatly reducing the amount of code needed to wire together an application and provide classes with their necessary dependencies. While it is fully possible to supply these dependencies to your classes manually, allowing the framework to perform these duties reduces the chances for error and generally speeds up the coding process.

h2(#theContext). The Context

At the heart of any Robotlegs implementation lies the Context. The Context, or Contexts as the case may be, provides the mechanism by which any given implementation's tiers will communicate. An application is by no means limited to a single Context, but for many use cases one Context is sufficient. With the ability to build modular applications on the Flash platform, you will see circumstances where multiple Contexts are necessary. The Context has three functions within an application: provide initialization, provide de-initialization, and provide the central event bus for communication.

h2(#mvcs). MVC+S

Robotlegs is equipped with a recommended implementation. This implementation follows the classic meta-design pattern known as Model-View-Controller (MVC), with the addition of a forth actor called Service. These tiers, throughout this document, are referred to as the "Core actors," or simply "actors."

This standard, or default implementation is meant to serve as an example of suggested best practices. Robotlegs does not intend to tie you to this example in any way, but it is provided as a suggestion. You are free to develop your own implementation to suit your favored nomenclature and development needs. If this is something you pursue, please let us know about it, as we are always interested in new approaches and it can potentially be included in the Robotlegs repository as an alternate implementation.

h3(#context). Context

Like all Robotlegs implementations the MVC+S implementation is centered around on or more Contexts. The context provides a central event bus and takes care of startup and shutdown of the Context.

h3(#modelAndModels). Model & Models

The Model tier is represented by the Model class. Classes that extend Model encapsulate and provide an API for data. Models send event notifications when work has been performed on the data model. Models are generally highly portable entities.

h3(#viewAndMediators). View & Mediators

The View tier is represented by the Mediator class. Classes that extend Mediator are used to handle framework interaction with View Components. A Mediator will listen for framework events, add event listeners to the View Components, and send framework events in response to events received from the View Components they are responsible for. This allows the developer to put application specific logic on the Mediator, and avoid coupling View components to specific applications. 

h3(#controllersAndCommands). Controller & Commands

The Controller tier is represented by the Command class. Commands are stateless, short-lived objects used to perform a single unit of work within an application. Commands are appropriate for communication between application tiers and are able to send system events that will either launch other Commands or be received by a Mediator to perform work on a View Component in response to the event. Commands are an excellent place to encapsulate the business logic of your application.

h3(#serviceAndServices). Service & Services

The Service tier is represented by the Service class. A class that extends Service is essentially a model for communicating with "the outside world" from within an application. Web services, file access, or any action that takes place outside of the scope of your application is appropriate for the Service class. Service classes dispatch system events in response to external events. A Service should be highly portable, encapsulating interaction with an external service.

h3(#frameworkEvents). Framework Events

Robotlegs uses native flash events for communication between framework actors. Custom events are typically utilized for this purpose, it is however possible to use existing Flash events for this same purpose. Robotlegs does not support Event bubbling, as it does not depend on the Flash display list as an event bus. Utilizing custom events allows developers to add properties to the Event that can be used as strongly typed payloads for system events between framework actors.

Events are sent from all framework actors: Mediators, Models, and Commands. Mediators are the only actors that receive framework events. Commands are triggered in response to framework events. An event can be both received by a Mediator as well as trigger a command.

Models and Services to not listen for or respond to events. Doing so would tightly couple them to application specific logic and reduce the potential for portability and reuse.

h2(#commands). Commands

Commands are short-lived stateless objects. They are instantiated, executed and then immediately disposed of. Commands are only executed in response to framework events and should never be instantiated or executed by other framework actors.

h3(#commandResponsibilities). Command Responsibilities

Commands are registered to a Context via that Context's CommandMap. The CommandMap is available by default in Context and Command classes. Commands are registered to the Context with an Event type, the Command class to execute in response to the Event, and optionally the Event class and a one off setting for when a Command should be executed once, and then unregistered for future occurrences of an Event.

h3(#triggeringCommands). Triggering Commands 

Commands are triggered by framework events dispatched by Mediators, Services, Models, and other Commands. Typically the Event that triggered the Command is injected into the Command giving the Command access to the Event's properties/payload:

<pre>
public class MyCommand extends Command
{
	[Inject]
	public var event:MyCustomEvent;
	
	[Inject]
	public var model:MyModel;
			
	override public function execute():void
	{
		model.updateData( event.myCustomEventPayload )
	}
}
</pre>

When the mapped command is instantiated in response to a framework event, all of the dependencies that have been mapped and marked with the [Inject] metadata tag are injected into the Command. In addition, the event instance that triggered the Command is also injected. After these dependencies have been supplied, the executed method is called automatically and the Command's work is performed. It is not necessary, and should never be done, to call the execute() method directly. This is the framework implementation's job.

h3(#chainingCommands). Chaining Commands

It is also possible to chain commands:

<pre lang="actionscript">
public class MyChainedCommand extends Command
{
	[Inject]
	public var event:MyCustomEvent;
	
	[Inject]
	public var model:MyModel;
			
	override public function execute():void
	{
		model.updateData( event.myCustomEventPayload )
		
		//the UPDATED_WITH_NEW_STUFF event triggers a command and is also received by
		//a mediator to update a View Component, but only if a response is requested
		if(event.responseNeeded)
		    dispatch( new MyCustomEvent( MyCustomEvent.UPDATED_WITH_NEW_STUFF, model.getCalculatedResponse() ) )
	}
}
</pre>

Using this approach it is possible to chain as many Commands as needed together. In the example above a conditional statement is used. If the condition is not met, the Command is not chained. This provides extreme flexibility within your Commands to perform work on your application.

h3(#decouplingTiers). Decoupling Application Tiers

Commands are a very useful mechanism for decoupling the various actors of an application. Because a Command is never instantiated or executed from a Mediator, Model or Service, these classes are never coupled to, or even aware of the existence of Commands.

To perform their duties, Commands may:

* Map Mediators, Models, Services, or other Commands within their Context
* Dispatch Events to be received by Mediators or trigger other Commands
* Be injected with Models, Services, and Mediators to perform work on directly

Something to note is that it is not recommended to interact directly with Mediators in a Command. While it is possible, it will couple that Mediator to that Command. Since Mediators, unlike Services and Models, are able to receive system Events, the better practice is to simply dispatch an Event from the Command and listen for it on Mediators that need to respond to the Events.

h2(#mediators). Mediators

The Mediator class is used to mediate a user's interaction with an application's View Components. A Mediator can perform this duty at multiple levels of granularity, mediating an entire application and all of its sub-components, or any and all of an application's sub-components directly.

h3(#mediatorResponsibilities). Mediator Responsibilities

Flash, Flex and AIR applications provide virtually limitless possibilities for rich visual user interface components. All of these platforms provide out of the box components such as DataGrids, Buttons, Labels and other common UI components. It is also possible to extend these basic components into custom components, create composite components, or write components from scratch.

A View Component is any UI component and/or its sub-components. A View Component is encapsulated, handling its own state and operations as much as possible. A View Component provides an API via events, simple methods, and properties upon which Mediators act upon to affect the View Component within a Context. Mediators are responsible for interacting with the framework on behalf of the View Components that they mediate. This includes listening for Events on the components and their sub-components, accessing methods, and reading/setting properties on the components.

A Mediator listens for Events on its View Component, and accesses data directly on the View Component via its exposed API. A Mediators acts on behalf of other framework actors by responding to their Events and modifying its View Component accordingly. A Mediator notifies other framework actors of Events created by the View Component by relaying those Events, or dispatching appropriate Events to the framework.

h3(#mappingAMediator). Mapping a Mediator

A Mediator can be mapped in any class that has has the _mediatorMap_ instance available. This includes Mediators, Context, and Command classes.

This is the syntax for mapping a mediator:
<pre>
mediatorMap.mapView( ViewClass, MediatorClass, autoCreate, autoRemove );
</pre>

h3(#automaticMediation). Automatic Mediation of View Components

When a view component class is mapped for mediation, you can specify if you would like to have the Mediator for the class created automatically. When this option is _true_ the context will listen for the view component instance to dispatch its ADDED_TO_STAGE event. When this event is received, the view component will be automatically mediated and its mediator can begin to send and receive framework events.

h3(#manualMediation). Manually Mediation of View Components

There are occasions where the automatic mediation of view components is not desired, or impossible. In these cases, it is possible to manually create the Mediator instance for a class:

<pre>mediatorMap.createMediator(contextView);</pre>

The above assumes that the view component was previously mapped to a mediator using the _mapView()_ method of the _mediatorMap_.

h3(#mappingTheContextView). Mapping the Main Application (_contextView_) Mediator

It is a common pattern to map the contextView to a mediator. This is a special situation, as the automatic mediation cannot be performed on the contextView, as it is already added to the stage and will no longer fire the appropriate events the _mediatorMap_ uses to provide this convenience. Typically, this mapping can be done inside the _startup()_ method of the Context that holds a reference to the _contextView_:

<pre>override public function startup():void
{
	mediatorMap.mapView(MediateApplicationExample, AppMediator);
	mediatorMap.createMediator(contextView);
}</pre>

The _contextView_ is now fully mediated and can send and receive framework events.

h3(#accessingMediatorViewComponent). Accessing a Mediator's View Component

When a View Component is added to the stage within a Context's contextView, it is by default mediated automatically based on configuration supplied to the MediatorMap when the mapping was made. In a basic mediator, the _viewComponent_ property is injected with the view component that is being mediated. A Mediator's _viewComponent_ property is of type Object. In most cases, we want access to a strongly typed object to receive the benefits provided by using strongly typed objects. To achieve this, we inject the typed instance of the view component that is being mediated:

<pre>
public class GalleryLabelMediator extends Mediator implements IMediator
{
	[Inject]
	public var myCustomComponent:MyCustomComponent;
		
	/**
	* overriding the onRegister method is a good chance to
	* add any system or View Component Events the Mediator
	* is interested in receiving.
	*/
	override public function onRegister():void
	{
		//adding an event listener to the Context for framework events
		addEventListenerTo( eventDispatcher, MyCustomEvent.DO_STUFF, handleDoStuff );
		//adding an event listener to the view component being mediated
		addEventListenerTo( myCustomComponent, MyCustomEvent.DID_SOME_STUFF, handleDidSomeStuff)
	}
	
	protected function handleDoStuff(event:MyCustomEvent):void
	{
		//setting a property on the view component from the
		//strongly typed event payload. The view component
		//will likely manage its own state based on this
		//new data.
		myCustomComponent.aProperty = event.payload
	}
	
	protected function handleDidSomeStuff(event:MyCustomEvent):void
	{
		//relaying the event to the framework
		dispatch(event)
	}
}
</pre>

Following this approach we now have easy direct access to the public properties ad methods of the mediated view component.

h3(#addingEventListenersToMediators). Adding Event Listeners to a Mediator

Event listeners are the eyes and ears of concrete Mediator classes. Since all communication within the framework is handles via native Flash events, event listeners will be placed on Mediators to respond to their interests. In addition to framework events, Mediators listen for events from the view components that they are actively mediating.

It is common to add event listeners in the onRegister method of the Mediator. At this phase of the Mediator's lifecycle, it has been registered and its view component and other dependencies have been injected. The onRegister method must be overridden in concrete Mediator classes. Event listeners may be added in other class methods as well, including event handler methods that are responding to both framework and view component events.

Mediators are equipped with a convenience method, _addEventListenerTo_. This method registers each event added to the Mediator, and ensures that the event is removed when the mediator is unregistered from the framework. It is important to remove events in Flash, as events that are added, but not removed from a class eliminate the Player's ability to perform runtime Garbage Collection on that class. It is possible to add your event listeners with the traditional Flash syntax, but be aware that you will also need to remove them manually as well.

h3(#mediatorsListeningFroFrameworkEvents). Listening for Framework Events

All of the actors in the framework carry an _eventDispatcher_ property that is injected into the class when it has been instantiated. The _eventDispatch_ is a Mediator's mechanism for sending and receiving framework events. 

@addEventListenerTo(eventDispatcher, SomeEvent.IT_IS_IMPORTANT, handleFrameworkEvent)@

Using this syntax, a Mediator is now listening for _SomeEvent.IT_IS_IMPORTANT_ which will be handled by a class method called _handleFrameworkEvent_

h3(#MediatorsDispatchingFrameworkEvents). Dispatching Framework Events

An equally important duty of a Mediator is sending out events to the framework that other actors might be interested in. These events are generally sent in response to some interaction with the mediated view component by the user of the application. Again, a convenience method is supplied to reduce some of the typing necessary to dispatch an event to the framework

@dispatch(new SomeEvent(SomeEvent.YOU_WILL_WANT_THIS, myViewComponent.someData))@

This event can now be received by other Mediators or execute a command. The Mediator that dispatched the event is not concerned with how other actors within the application will respond to the event, it is simply broadcasting the message that something has occurred. A mediator may also listen for the events that it dispatches, and respond to them accordingly.

h3(#mediatorsListeningForComponentEvents). Listening for View Component Events

A Mediator is responsible for listening to events dispatched by the view component being mediated. This can be a single component, such as a TextField or Button, or a complex hierarchy of nested components. When a view component event has been added to a mediator it will be handled by the class method designated to handle the event. As with framework events, the _addEventListenerTo_ convenience method is the preferred syntax for adding event listeners to a mediator:

@addEventListenerTo(myMediatedViewComponent, SomeEvent.USER_DID_SOMETHING, handleUserDidSomethingEvent)@

In response to an event received from a view component, a mediator might:

* examine the payload of the event (if it exists)
* examine the current state of the view component
* perform work on the view component as required
* send framework events to notify other actors that something has occurred

h3(#accessingModelsAndServicesFromMediators). Accessing Models and Services via a Mediator

It is possible to access a Model and/or Service directly from a Mediator. This practice is discourage, however, as it will tightly couple the Mediator to the Models and/or Services that it has direct access to. It is considered better practice to use framework events for communication between these tiers. 

h3(#accessingOtherMediatorsFromAMediator). Accessing Other Mediators

As with Services and Models, it is possible to inject and access other Mediators in a Mediator. Again, this practice is highly discourage as the tight coupling can easily be avoided by communication through framework events.

h2(#models). Models

The Model class is used to to manage access to an application's data model. A Model provides an API that is used by other framework actors to access, manipulate, and update application data. This data includes, but is not limited to, native data types such as Strings, Arrays, or ArrayCollection as well as domain specific Objects or collections of these.

h3(#modelResponsibilities). Model Responsibilities

Concrete Model classes encapsulate and provide an API for the application data model. The Model class, as extended for application specific usage, is the gatekeeper for your applications data. Other actors in the application makes requests for data through the API provided by the Model. As data is updated through the Model, the Model is equipped to broadcast events to the framework informing other actors of changes to the data model so they may adjust their state accordingly. 

In addition to controlling access to the data model, the Model is routinely used to perform operations on the data to keep the data in a valid state. This includes performing calculations on the data, or other areas of domain specific logic. This responsibility of the Model is extremely important. The Model is the tier of any given application with the highest potential for portability. By placing domain logic on the Model, future implementations of the model will not have to repeat this same logic as they would if it was placed in the View or Controller tiers.

As an example, your Model class might perform a sales tax calculation on the shopping cart data that it is string. A Command will access this method, and the final calculation will be dispatched as an event that a Mediator is listening for. The mediator will then update its view component with the updated value. In the first iteration of the application it was a typical Flex application. This calculation could have easily been performed on a Mediator, or event the view itself. The second iteration of the application is a mobile Flash application that requires an entirely new view form factor. Since this logic is contained in the Model, it can be reused for both form factors with entirely different views.

h3(#mappingAModel). Mapping a Model

There are several methods available on the injector for mapping your Model classes for injection into your framework actors. In addition, these methods can be used for injection virtually ANY class into your classes.

To map an existing instance for injection that will be treated as a singleton, use the following syntax:
<pre>injector.mapValue(MyModelClass, myModelClassInstance)</pre>

To map a new instance of a class for each injection, use the following syntax:
<pre>injector.mapClass(MyModelClass, MyModelClass)</pre>
Additionally, this can be used to map interfaces for injection, with a concrete class that implements the interface being injected:
<pre>injector.mapClass(IMyModelClass, MyModelClass)</pre>

To map a singleton instance of an interface or class, use the following syntax:
<pre>injector.mapSingleton(MyModelClass, MyModelClass)</pre>

It is important to note that when referring to a singleton above, it is not a Singleton. It is not enforced outside of the Context as a Singleton. The injector simply insures that one, and only one, instance of the class will be injected. This is vital for Model classes that are handling your application data model.

h3(#dispatchingEventsFromModel). Dispatching Events from a Model

The Model class provides a convenience method _dispatchEvent_ for sending framework events:

<pre>dispatchEvent( new ImportantDataEvent(ImportantDataEvent.IMPORTANT_DATA_UPDATED))</pre>

Events can be dispatched for any number of reasons, including but not limited to:

* Data has been initialized ad is ready for other actors to use
* Some piece of data has been added to the Model
* Data has been removed from the Model
* Data has changed or updated
* State has been changed related to the data

h3(#listeningForEventsInModel). Listening for Framework Events in a Model

While this is technically possible it is *highly discouraged*. Don't do it. Just for the sake of clarity. *Don't do it*. If you do, don't say you weren't warned.

h2(#services). Services

Services are utilized to access resources outside of the scope of the application. This is including, but certainly not limited to:

* web services
* file system
* data bases
* RESTful APIs
* other Flash application via localConnection

Services encapsulate this interaction with external entities, and manage the results, faults, and other events that result from this interaction.

You might notice that the Service and Model base classes are very similar. In fact, you might notice that outside of the class name, they are exactly the same. Why have two classes then? Model and Service classes have entirely different responsibilities within an application. The concrete implementations of these classes will not be similar. Without this separation, you will generally find external service access being performed on Model classes. This creates Models that have the multiple duty of accessing external data, parsing results, handling faults, managing application data state, providing an API for data, providing an API for the service, etc. Separating these tiers helps to alleviate this problem.

h3(#serviceResponsibilities). Responsibilities of Services

A Service class provides your application with an API for interacting with an external service. A service class will contact the external service ad manage the response that it receives. Services are typically stateless entities. They do not store the data that is returned from an external service, but instead send framework events so that response data and faults can be managed by the appropriate framework actors.

h3(#mappingService). Mapping a Service

There are several methods available on the injector for mapping your Service classes for injection into your framework actors. In addition, these methods can be used for injection virtually ANY class into your classes.

To map an existing instance for injection that will be treated as a singleton, use the following syntax:
<pre>injector.mapValue(MyServiceClass, myServiceClassInstance)</pre>

To map a new instance of a class for each injection, use the following syntax:
<pre>injector.mapClass(MyServiceClass, MyServiceClass)</pre>
Additionally, this can be used to map interfaces for injection, with a concrete class that implements the interface being injected:
<pre>injector.mapClass(IMyServiceClass, MyServiceClass)</pre>

To map a singleton instance of an interface or class, use the following syntax:
<pre>injector.mapSingleton(MyServiceClass, MyServiceClass)</pre>

It is important to note that when referring to a singleton above, it is not a Singleton. It is not enforced outside of the Context as a Singleton. The injector simply insures that one, and only one, instance of the class will be injected.

h3(#serviceListeningForFrameworkEvents). Listening for Framework Events in a Service

While this is technically possible it is *highly discouraged*. Don't do it. Just for the sake of clarity. *Don't do it*. If you do, don't say you weren't warned.

h3(#serviceDispatchingFrameworkEvents). Dispatching Framework Events

The Service class provides a convenience method _dispatchEvent_ for sending framework events:

<pre>dispatchEvent( new ImportantServiceEvent(ImportantServiceEvent.IMPORTANT_SERVICE_EVENT))</pre>

h2(#unitTesting). Unit Testing

_coming soon_


















